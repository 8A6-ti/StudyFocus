<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>StudyFocus Overlay</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: transparent;
      font-family: 'Segoe UI', sans-serif;
    }

    .overlay-container {
      width: 300px;
      background-color: rgba(20, 20, 20, 0.9);
      border-radius: 16px;
      box-shadow: 0 0 12px rgba(0, 0, 0, 0.3);
      color: white;
      padding: 12px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      transition: height 0.3s ease, background-color 0.3s ease;
      overflow: hidden;
      height: 120px; /* Default height */
    }

    .overlay-container:hover {
      height: 400px;
      background-color: rgba(40, 40, 40, 0.95);
    }

    .line {
      font-size: 14px;
      margin: 4px 0;
    }

    .buttons {
      margin-top: 8px;
      display: flex;
      justify-content: space-between;
    }

    .button {
      background-color: #444;
      border: none;
      padding: 6px 10px;
      border-radius: 8px;
      color: white;
      font-size: 13px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .button:hover {
      background-color: #666;
    }

    .extra-data {
      font-size: 13px;
      margin-top: 12px;
      overflow-y: auto;
      max-height: 200px;
    }

    .extra-data h4 {
      margin: 6px 0 2px;
      color: #cccccc;
    }

    .objectives-list {
      list-style-type: none;
      padding: 0;
      margin: 8px 0;
    }

    .objective-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      padding: 6px;
      border-radius: 6px;
      transition: background-color 0.2s ease;
    }

    .objective-item:hover {
      background-color: rgba(70, 70, 70, 0.5);
    }

    .objective-checkbox {
      margin-right: 8px;
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .objective-text {
      flex-grow: 1;
      font-size: 13px;
    }

    .objective-timestamp {
      font-size: 11px;
      color: #aaa;
      margin-left: 8px;
    }

    .objective-completed {
      text-decoration: line-through;
      color: #8c8c8c;
    }

    .objective-item.completed {
      background-color: rgba(0, 100, 0, 0.3);
    }

    .progress-bar {
      height: 6px;
      background-color: #333;
      border-radius: 3px;
      margin-top: 10px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background-color: #4CAF50;
      transition: width 0.3s ease;
    }

    .section-divider {
      border-top: 1px solid #666;
      margin: 10px 0;
    }

    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }

    .status-active {
      background-color: #4CAF50;
    }

    .status-rest {
      background-color: #FFA500;
    }

    .status-warning {
      background-color: #F44336;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }

    .allowed-apps {
      margin-top: 10px;
    }

    .allowed-apps h4 {
      margin-bottom: 5px;
    }

    .allowed-app {
      font-size: 12px;
      margin: 3px 0;
      color: #7bff7b;
    }

    .timer-display {
      font-size: 22px;
      font-weight: bold;
      text-align: center;
      margin: 5px 0;
    }
    
    .warning-banner {
      background-color: rgba(220, 53, 69, 0.8);
      padding: 8px;
      margin: 5px 0;
      border-radius: 8px;
      text-align: center;
      display: none;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0% { background-color: rgba(220, 53, 69, 0.6); }
      50% { background-color: rgba(220, 53, 69, 0.9); }
      100% { background-color: rgba(220, 53, 69, 0.6); }
    }
    
    .countdown {
      font-weight: bold;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <div class="overlay-container">
    <div>
      <div class="line">
        <span class="status-indicator status-active"></span>
        <span id="statusText">Study Mode</span>
      </div>
      <div class="timer-display" id="mainTimer">25:00</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 100%;"></div>
      </div>
      <div class="warning-banner" id="warningBanner">
        Unallowed app detected!<br>
        Returning to allowed apps in <span id="countdown" class="countdown">5</span>
      </div>
    </div>

    <div class="buttons" id="actions" style="display: none;">
      <button class="button" onclick="switchMode()" id="modeButton">Switch to Rest</button>
      <button class="button" onclick="endSession()">End Session</button>
    </div>

    <div class="extra-data" id="extraData">
      <div class="section-divider"></div>
      <h4>Objectives</h4>
      <ul class="objectives-list" id="objectivesList">
        <!-- Objectives will be added here dynamically -->
      </ul>

      <div class="section-divider"></div>
      <h4>Allowed Apps</h4>
      <div class="allowed-apps" id="allowedApps">
        <!-- Allowed apps will be added here dynamically -->
      </div>
    </div>
  </div>

  <script>
    // stuff we need globally
    let isStudyMode = true;
    let objectives = [];
    let allowedApps = [];
    let currentProgress = 100;
    let timeData = { time: "25:00", restTime: "5:00" };
    let countdownInterval = null;
    let secondsLeft = 5;
    
    // some basic settings
    const REFRESH_INTERVAL = 10000; // check every 10 secs
    const COUNTDOWN_SECONDS = 5; // give em 5 secs to switch back

    // Show buttons only on hover
    const container = document.querySelector('.overlay-container');
    container.addEventListener('mouseenter', () => {
      document.getElementById('actions').style.display = 'flex';
    });
    container.addEventListener('mouseleave', () => {
      document.getElementById('actions').style.display = 'none';
    });
  
    // updates the big timer display
    function updateTimerDisplay() {
      const timeDisplay = document.getElementById('mainTimer');
      timeDisplay.textContent = isStudyMode ? timeData.time : timeData.restTime;
    }

    // changes the little colored dot and status text
    function updateStatusIndicator() {
      const statusText = document.getElementById('statusText');
      const statusIndicator = document.querySelector('.status-indicator');
      
      statusIndicator.className = 'status-indicator';
      
      if (isStudyMode) {
        statusText.textContent = 'Study Mode';
        statusIndicator.classList.add('status-active');
      } else {
        statusText.textContent = 'Rest Mode';
        statusIndicator.classList.add('status-rest');
      }
    }

    // puts the objectives list on screen
    function renderObjectives() {
      const objectivesList = document.getElementById('objectivesList');
      objectivesList.innerHTML = '';

      if (!objectives || objectives.length === 0) {
        objectivesList.innerHTML = '<div class="line">No objectives set for this session.</div>';
        return;
      }

      objectives.forEach((objective, index) => {
        const objectiveItem = document.createElement('li');
        objectiveItem.className = 'objective-item';
        if (objective.completed) {
          objectiveItem.classList.add('completed');
        }

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'objective-checkbox';
        checkbox.checked = objective.completed || false;
        
        // Only allow interaction if objective is not completed
        if (!objective.completed) {
          checkbox.addEventListener('change', () => toggleObjectiveCompletion(index));
        } else {
          checkbox.disabled = true; // Disable checkbox if objective is completed
        }

        const objectiveText = document.createElement('span');
        objectiveText.className = 'objective-text';
        if (objective.completed) {
          objectiveText.classList.add('objective-completed');
        }
        objectiveText.textContent = objective.text;

        objectiveItem.appendChild(checkbox);
        objectiveItem.appendChild(objectiveText);

        if (objective.completedAt) {
          const timestamp = document.createElement('span');
          timestamp.className = 'objective-timestamp';
          timestamp.textContent = formatTimestamp(objective.completedAt);
          objectiveItem.appendChild(timestamp);
        }

        objectivesList.appendChild(objectiveItem);
      });
    }

    // makes timestamps look nice
    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      return `${hours}:${minutes}`;
    }

    // marks an objective as done
    function toggleObjectiveCompletion(index) {
      if (!objectives[index].completed) {
        objectives[index].completed = true;
        objectives[index].completedAt = new Date().toISOString();
        
        // Send update to backend
        fetch('http://localhost:5000/api/update-objective', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            index: index,
            completed: true,
            completedAt: objectives[index].completedAt
          })
        }).catch(err => console.error('Failed to update objective:', err));
        
        renderObjectives();
      }
    }

    // shows what apps are allowed to use
    function renderAllowedApps() {
      const allowedAppsContainer = document.getElementById('allowedApps');
      allowedAppsContainer.innerHTML = '';

      if (!allowedApps || allowedApps.length === 0) {
        allowedAppsContainer.innerHTML = '<div class="line">No apps are whitelisted.</div>';
        return;
      }

      allowedApps.forEach(app => {
        const appElement = document.createElement('div');
        appElement.className = 'allowed-app';
        appElement.textContent = `${app.title} (${app.process})`;
        allowedAppsContainer.appendChild(appElement);
      });
    }

    // flips between study and rest modes
    function switchMode() {
      isStudyMode = !isStudyMode;
      
      // Update UI
      updateStatusIndicator();
      updateTimerDisplay();
      
      // Update button text
      const modeButton = document.getElementById('modeButton');
      modeButton.textContent = isStudyMode ? 'Switch to Rest' : 'Switch to Study';
      
      // Call backend API to switch mode
      fetch('http://localhost:5000/api/switch-mode', { 
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mode: isStudyMode ? 'study' : 'rest' })
      }).catch(err => console.error('Failed to switch mode:', err));
    }

    // lets user bail out of the session
    function endSession() {
      if (confirm('Are you sure you want to end this study session?')) {
        fetch('http://localhost:5000/api/end-session', { 
          method: 'POST' 
        }).then(() => {
          // Close the overlay window
          if (window.electron) {
            window.electron.closeWindow();
          }
        }).catch(err => console.error('Failed to end session:', err));
      }
    }
    
    // scary countdown when using wrong apps
    function startAppDetectionCountdown() {
      const warningBanner = document.getElementById('warningBanner');
      const countdownElement = document.getElementById('countdown');
      const statusIndicator = document.querySelector('.status-indicator');
      
      // Show warning banner
      warningBanner.style.display = 'block';
      
      // Change status indicator to warning
      statusIndicator.className = 'status-indicator status-warning';
      
      // Reset and start countdown
      secondsLeft = COUNTDOWN_SECONDS;
      countdownElement.textContent = secondsLeft;
      
      if (countdownInterval) {
        clearInterval(countdownInterval);
      }
      
      countdownInterval = setInterval(() => {
        secondsLeft--;
        countdownElement.textContent = secondsLeft;
        
        if (secondsLeft <= 0) {
          // Time's up - deduct from rest time
          clearInterval(countdownInterval);
          deductFromRestTime();
        }
      }, 1000);
    }
    
    // stops the scary countdown
    function stopAppDetectionCountdown() {
      const warningBanner = document.getElementById('warningBanner');
      
      // Hide warning banner
      warningBanner.style.display = 'none';
      
      // Update status indicator back to normal
      updateStatusIndicator();
      
      // Clear the countdown
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }
    
    // takes away rest time when caught using wrong apps
    function deductFromRestTime() {
      // Call backend to deduct time from rest
      fetch('http://localhost:5000/api/deduct-rest-time', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ deductSeconds: 30 }) // Deduct 30 seconds as penalty
      })
      .then(response => response.json())
      .then(data => {
        if (data.time) {
          timeData = data.time;
          updateTimerDisplay();
        }
      })
      .catch(err => console.error('Failed to deduct rest time:', err));
      
      // Reset countdown for next time
      stopAppDetectionCountdown();
    }
    
    // makes sure current app is ok to use
    function checkCurrentApp(currentAppData) {
      // This function would be called with the current active app info
      // For demo purposes, we'll simulate this with random detection
      const isAllowed = allowedApps.some(app => 
        app.process === currentAppData.process || app.title === currentAppData.title
      );
      
      if (!isAllowed) {
        startAppDetectionCountdown();
      } else {
        stopAppDetectionCountdown();
      }
    }

    // lets the backend update our ui
    window.updateOverlayData = function(data) {
      if (data && data.time) {
        timeData = data.time;
        updateTimerDisplay();
      }
  
      if (data && data.objectives && Array.isArray(data.objectives.obj)) {
        // Transform array of strings into array of objective objects if needed
        objectives = data.objectives.obj.map((obj, index) => {
          // If already an object with completion status, use it
          if (typeof obj === 'object' && obj !== null) {
            return obj;
          }
          // Otherwise, create an object from the string
          return {
            text: obj,
            completed: false
          };
        });
        renderObjectives();
      }
      
      if (data && data.apps) {
        allowedApps = data.apps;
        renderAllowedApps();
      }
      
      // Update progress bar based on time left
      if (data && data.progress !== undefined) {
        currentProgress = data.progress;
        document.getElementById('progressFill').style.width = `${currentProgress}%`;
      }
      
      // Check if current app is whitelisted
      if (data && data.currentApp) {
        checkCurrentApp(data.currentApp);
      }
    };
    
    // grab initial data
    fetch('http://localhost:5000/api/getdata/all')
      .then(response => response.json())
      .then(data => {
        window.updateOverlayData(data);
      })
      .catch(error => {
        console.error("oops, couldn't get overlay data:", error.message);
      });
      
    // keep checking for new data
    setInterval(() => {
      fetch('http://localhost:5000/api/getdata/all')
        .then(response => response.json())
        .then(data => {
          window.updateOverlayData(data);
        })
        .catch(error => {
          console.error("dang, refresh failed:", error.message);
        });
    }, REFRESH_INTERVAL);
  </script>  
</body>
</html>